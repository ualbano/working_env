#! /bin/bash

# Path the parent folder of this file
CUSTOM_ENV_PATH=$(dirname "$(realpath "$0")")
CUSTOM_ENV_FILE="$CUSTOM_ENV_PATH/$(basename "$0")"
PACKAGE_LIST_FILE="$CUSTOM_ENV_PATH/packages"
# I chosse to use an array. In this case the command can be overloaded by other files.
PKG_INSTALL_CMD=${PKG_INSTALL_CMD:-(apt install -y)}

#Editor setup
# shellcheck disable=SC2139
alias nvim="nvim -u ${CUSTOM_ENV_PATH}/nvim_init.lua"
export EDITOR=nvim

# Common Commands
alias q='exit'
alias c='clear'
alias h='history'
alias p='cat'
alias pd='pwd'
alias t='time'
alias k='kill'
alias null='/dev/null'
alias vim="nvim"
alias home='cd ~'
alias root='cd /'
alias clip='xclip -sel clip'

# Git shortcuts
alias gs='git status'
alias gp='git pull'
alias gP='git push'
alias ga='git add -p'
alias gA='git add -p -A'
alias gc='git commit'
alias gcP='git commit && git push'
alias gAc='git add -p -A && git commit'
alias lg='lazygit'

# Functions

# general purposes function to get the next free port
function free_port() {
  port=${1:-8080}

  while [ -n "$(ss -tan4H "sport = $port")" ]; do
    port=$((port + 1))
  done
  echo $port
}

function add_line_if_not_exists() {
  local line_to_add="$1"
  local file_path="$2"

  if ! grep -qxF "$line_to_add" "$file_path" 2>/dev/null; then
    echo "$line_to_add" >>"$file_path"
    echo "Line was added to '$file_path'."
  else
    echo "Line already exists in '$file_path'. No action required."
  fi
}

function install_packages() {
  # shellcheck disable=SC2207
  packages=($(cat "$PACKAGE_LIST_FILE"))
  echo "Install packages ${packages[*]}"
  sudo "${PKG_INSTALL_CMD[@]}" "${packages[@]}"
}

function inner_update() {
  install_packages
  add_line_if_not_exists "test -f ${CUSTOM_ENV_FILE} && . ${CUSTOM_ENV_FILE} || true" "$HOME/.bashrc"
  add_line_if_not_exists "test -f ${CUSTOM_ENV_FILE} && . ${CUSTOM_ENV_FILE} || true" "$HOME/.zshrc"
}

#This function should update changes on this setup.
#It first load the new version and than run the inner update.
#This function can also be used to installing
function update_env() {
  source "$CUSTOM_ENV_FILE"
  inner_update
}

# The Idea of this lines, that I can add additional files for specific setups (like work).
# These files can be maintained in the .addional_envs file and tracked by another repo.
ADDIONAL_ENV_FILES="$CUSTOM_ENV_PATH/.addional_envs"
test -f "$ADDIONAL_ENV_FILES" && source "$ADDIONAL_ENV_FILES" || true
